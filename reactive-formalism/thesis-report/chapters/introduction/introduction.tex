\let\textcircled=\pgftextcircled
\chapter*[Introduction]{Introduction}
\label{chap:intro}
\addcontentsline{toc}{chapter}{Introduction}

\epigraph{\hspace{4ex}\textit{"Lasciate ogne speranza, voi ch'intrate."}}{--- Dante Alighieri,\\ \textit{Divina Commedia}}

 
With the evolution of technologies brought in by the new millennium and the exponential growth of Internet-based services targeting millions of users all over the world, the Software Engineers' community has been continuously tested by an ever growing number of challenges related to management of increasingly large amounts of user data\cite{furht2010handbook}. 

This phenomena is commonly referred to as Big Data. A very popular 2001 research report\cite{laney20013d} by analyst Doug Laney, proposes a definition of big data based on its three defining characteristics:

\begin{itemize}
\item \textit{Volume}: the quantity of data applications have to deal with, ranging from small - e.g. locally maintained Databases - to large - e.g. distributed File Systems replicated among data centers.
\item \textit{Variety}: the type and structure of data, ranging from classic SQL-structured data sets to more diversified and unstructured ones such as text, images, audio and  video. 
\item \textit{Velocity}: the speed at which data is generated, establishing the difference between pull-based systems, where data is synchronously pulled by the consumer, and push-based systems, more suited for handling real-time data by asynchronously pushing it to its clients.
\end{itemize}

Each of these traits directly influences the way programming languages, APIs and databases are designed today. The increasing volume calls for a declarative approach to data handling as opposed to an imperative one, resulting in the developer's focus shifting from how to compute something to what it is to be computed in the first place\cite{fahland2009declarative}. The diversification of data, on the other hand, is the main drive for the research and development of noSQL approaches to data storage. Lastly, the increase in velocity fuels the need for event-driven, push-based models of computation that can better manage the high throughput of incoming data\cite{meijer2012your}. 

In this context, the concept of \textit{reactive programming} has gained much traction in the developer's community as a paradigm well-suited for the development of asynchronous  event-driven applications\cite{bainomugisha2013survey}. Unfortunately, reactive programming has been at the center of much discussion, if not confusion, with regards to its definition, properties and principles that identify it\cite{meijer2014reactive}.

The goal of our work is to use mathematics as a tool to formalize the concept of reactive programming from a theoretical perspective.  We are going to do so by utilizing constructs and ideas from functional programming and category theory with the purpose of formally deriving a set of types and interfaces embedding the essence of reactive programming. We will then continue with the development of a reference reactive library which builds upon the previously derived theoretical foundations. 

\section*{Motivation}
\addcontentsline{toc}{section}{Motivation}

As we mentioned above, reactive programming's steep increase in popularity in the last few years\cite{bainomugisha2013survey} has come with a number of issues with regards to it's defining properties. Individual people, as well as industries, have been trying to push their own definition of reactive programming to the community, often placing their own interests before objectivity\cite{meijer2014reactive}.

We find the current state of things to be unacceptable as it undermines the scientific foundations and reputation of our community and field. This lack of a scientific and formal analysis of the concepts involved in reactive programming gives motivation to the work and research presented in this report.

To the best of our knowledge, we are not aware of any previous work which analyses reactive programming from a theoretical standpoint or derives its types and interfaces though the use of mathematics. Our research will take a strictly formal and mathematical approach to the derivation of a theory around reactive programming, reinstating objectivity as the main protagonist in this much opinionated field.

\section*{Goals \& Contributions}
\addcontentsline{toc}{section}{Goals \& Contributions}

The goal of this work is to provide types and interfaces that describe the real essence of the reactive paradigm, aiding engineers that wish to use or develop reactive libraries in understanding and taking more informed decisions on the matter.

This goal is achieved by providing a mathematical derivation of the reactive types, starting from their interactive counterparts and making use of theoretical concepts from category theory. These derived types are then used in the implementation of a formal reactive library where the purpose is showing how the theoretical definitions given to the various components can effectively be translated into working code. 

Together with the formal definition of the paradigm, this work contributes to the the field of reactive programming with a reference implementation for a production level reactive library, as well as a highlight of the issues and challenges encountered when bridging from the theoretical foundations of reactive programming to a concrete implementation of a reactive API. 

With the help of this report and the associated code repository, any software engineer interested in the topic should be able to understand the theoretical foundations behind the reactive paradigm and develop a reactive library in any language of choice.

\section*{Research Questions}
\addcontentsline{toc}{section}{Research Questions}

The work presented in this report will focus on answering the following research questions:

\begin{itemize}
\item \textbf{What does it mean to be reactive? Which class of problems does it solve? How does this relate to the real world libraries that claim to be reactive?}

Before any attempts at a formalization can be carried out, we need to clearly identify the class of problems the reactive paradigm is fit for solving, understanding what are the issues and concerns such problems present, thus setting the basis for a formalization to be defined. Additionally, we are going to analyze the current libraries and APIs that claim to be reactive, and see how they relate to our definition.

\item \textbf{Can we use existing mathematical and computer science theory in order to formally derive a definition for reactive programming?}

Once we have a clear definition of the meaning of reactive and the class of problems it solves, we are going to look at existing theories in mathematics and computer science that would allow us to derive a set of types/interfaces representing the essence of reactive programming. In order to make our work sound, we will then need to prove the connection between the derived types and the definition resulting from the first research question.
\end{itemize}

\section*{Related Work}
\addcontentsline{toc}{section}{Related Work}

Discuss stuff that I read in order to do this work, see repo. Most probably move this section to Introduction or separate chapter.

\section*{Overview}
\addcontentsline{toc}{section}{Overview}

\textit{Chapter 1} introduces the scope of our research, providing a definition of reactive programming, the motivation and reasoning behind our research and an overview of the current technologies and APIs that claim to belong to the world of reactive programming. \textit{Chapter 2} presents the mathematical derivation of the reactive types and interfaces, starting from the definition of \code{Iterable} and ending with that of \code{Observable}. \textit{Chapter 3} builds the bridge between the formal definition of the reactive types and a production level implementation of the paradigm, highlighting the technical issues as well as analyzing the relations with the previously discussed formal definitions. \textit{Chapter 4} concludes with final thought and future work.

\section*{Notation \& Conventions}
\addcontentsline{toc}{section}{Notation \& Conventions}

In the exposition of our work we will make use of Haskell as the reference programming language. This decision is motivated by the language's strong connection with mathematics and category theory, as well as it's clean syntax. These features will make the code both easy to read and explicit in the side effects that come into play in the various definitions. A minimal knowledge of Haskell's syntax - type declaration, lambda abstraction and IO monad - is assumed to be known by the reader in the exposition of this report. 

All the code presented in this report, a minimal complete theoretical implementation and a reference implementation of a reactive library can be found at the associated code repository on Github - \url{https://github.com/Widar91/Thesis}\todo{Fix repo organization}. 

\todo[inline]{Fix Biblio}