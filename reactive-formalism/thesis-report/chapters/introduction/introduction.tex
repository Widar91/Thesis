\let\textcircled=\pgftextcircled
\chapter*[Introduction]{Introduction}
\label{chap:intro}
\addcontentsline{toc}{chapter}{Introduction}

\epigraph{\hspace{4ex}\textit{"Lasciate ogne speranza, voi ch'intrate."}}{--- Dante Alighieri,\\ \textit{Divina Commedia}}

 
With the evolution of technologies brought in by the new millennium and the exponential growth of Internet-based services targeting millions of users all over the world, the Software Engineers' community has been continuously tested by an ever growing number of challenges related to management of increasingly large amounts of user data\cite{furht2010handbook}. 

This phenomena is commonly referred to as Big Data. A very popular 2001 research report\cite{laney20013d} by analyst Doug Laney, proposes a definition of big data based on its three defining characteristics:

\begin{itemize}
\item \textit{Volume}: the quantity of data applications have to deal with, ranging from small - e.g. locally maintained Databases - to large - e.g. distributed File Systems replicated among data centers.
\item \textit{Variety}: the type and structure of data, ranging from classic SQL-structured data sets to more diversified and unstructured ones such as text, images, audio and  video. 
\item \textit{Velocity}: the speed at which data is generated, establishing the difference between pull-based systems, where data is synchronously pulled by the consumer, and push-based systems, more suited for handling real-time data by asynchronously pushing it to its clients.
\end{itemize}

Each of these traits directly influences the way programming languages, APIs and databases are designed today. The increasing volume calls for a declarative approach to data handling as opposed to an imperative one, resulting in the developer's focus shifting from how to compute something to what it is to be computed in the first place\cite{fahland2009declarative}. The diversification of data, on the other hand, is the main drive for the research and development of noSQL approaches to data storage. Lastly, the increase in velocity fuels the need for event-driven, push-based models of computation that can better manage the high throughput of incoming data\cite{meijer2012your}. 

In this context, the concept of \textit{reactive programming} has gained much traction in the developer's community as a paradigm well-suited for the development of asynchronous  event-driven applications\cite{bainomugisha2013survey}. Unfortunately, reactive programming has been at the center of much discussion, if not confusion, with regards to its definition, properties and principles that identify it\cite{meijer2014reactive}.

The goal of our work is to use mathematics as a tool to analyze today's commercial reactive libraries and understand how they relate to the theoretical concept of reactive programming.  We are going to do so by utilizing concepts and ideas from functional programming and category theory with the purpose of deriving the reactive types, and will subsequently continue with the development of a reference reactive library which builds upon the previously derived theoretical foundations. 

\section*{Contributions}
\addcontentsline{toc}{section}{Contributions}

To the best of our knowledge, we are not aware of any previous work which analyses reactive programming from a theoretical standpoint or derives its types and interfaces though the use of mathematics.

The most commonly known attempt at defining reactive programming is the Reactive Manifesto\cite{reactive-manifesto}, a document that tries to describe reactive systems in terms of design principles and conceptual architecture. Although certainly insightful, we feel the document targets a more managing-focused audience as opposed to software developers and engineers. 

Our work, on the other hand, aims at providing types and interfaces that describe the real essence of the reactive paradigm, aiding engineers that wish to use or develop reactive libraries in understanding and taking more informed decisions on the matter.

This goal is achieved by providing a mathematical derivation of the reactive types, starting from they interactive counterparts and making use of theoretical concepts from category theory. These derived types are then used in the implementation of a formal reactive library where the purpose is showing how the theoretical definitions given to the various components can effectively be translated into working code. 

Together with this formal definition of the paradigm, this work presents a reference implementation for a production level reactive library, as well as an highlight of the issues and challenges encountered when bridging from the theoretical foundations of reactive programming to a concrete implementation of a reactive API. 

With the help of this report and the associated code repository, any software engineer interested in the topic should be able to understand the theoretical foundations behind the reactive paradigm and develop a reactive library in any language of choice.

\section*{Overview}
\addcontentsline{toc}{section}{Overview}

Chapter 1 introduces the scope of our research, providing a definition of reactive programming, the motivation and reasoning behinf our research and an overview of the current technologies and APIs that claim to belong to the world of reactive programming. Chapter 2 presents the mathematical derivation of the reactive types and interfaces, starting from the definition of \code{Iterable} and ending with that of \code{Observable}. Chapter 3 builds the bridge between the formal definition of the reactive types and a production level implementation of the paradigm, highlighting the technical issues as well as analyzing the relations with the previously discussed formal definitions. Chapter 4 concludes with final thought and future work.

\section*{Notation \& Conventions}
\addcontentsline{toc}{section}{Notation \& Conventions}

In the exposition of our work we will make use of Haskell as the reference language. This decision is motivated by the language's strong connection with mathematics as well as it's clean syntax.

All the code presented in this report, a minimal complete theoretical implementation and a full blown library implementation of a reactive library can be found at the associated code repository on \href{https://github.com/Widar91/Thesis/tree/master/reactive-formalism/rx-hs}{Github}. 
