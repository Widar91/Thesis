\let\textcircled=\pgftextcircled
\Chapter{Out of the rabbit hole}{Towards a usable API}
\label{chap:outoftherabbithole}

\epigraph{\hspace{4ex}\textit{TBD}}{--- Lewis Carol,\\ \textit{Alice in Wonderland}}

So far we focused our analysis on the essence of the \code{Observable} interface, setting aside the many operational concerns that would come up when trying to implement these concepts into a usable, commercial API. In this chapter we are going to build the bridge between our theoretical definition of \code{Observable} and a concrete and usable implementation of a reactive library, to which we will refer to as Rx.

In the remained of the discussion, we are going to introduce the \textit{Reactive Contract}, a set of assumptions on the reactive types our library is going to build upon, \textit{Schedulers}, which will allow us to bring concurrency into our reactive equation, \textit{Subscriptions}, used to implement a mechanism for premature stream cancellation and, finally, \textit{Operators}, the means that will make our reactive streams composable.

For the sake of clarity and completeness, the following set of interfaces represents the starting point for our discussion:\footnote{\code{subscribe} has been renamed to \code{\_subscribe} in order to both avoid naming conflicts later on in the discussion and reflect the fact that it should not be used from the outside.}\\

\hminted 
newtype Observable a = Observable 
	{ _subscribe :: Observer a -> IO ()
	}
data Observer a = Observer 
	{ onNext      :: a -> IO ()
	, onError     :: SomeException -> IO ()
	, onCompleted :: IO ()
	}
\end{minted}
\\

It is worth noting that even though the Observable's theoretical foundations lie in the realm of functional programming, the road to make it usable is full of obstacles that are often better tackled using imperative programming features such as state. As much as I personally prefer a functional and pure approach to programming, I will favor, in the rest of the discussion, the solution that most clearly and easily solves the problem, be that functional of imperative.

\section{The Reactive Contract}
\label{sec:contract}

- Remember best effort cancellation.

\section{Concurrency with Schedulers}

At the end of Section \ref{obscont} we discussed how \code{Observable}s, by default, handle data by means of a synchronous pipeline, blocking the processing of successive elements via the call stack. It is worth mentioning again how this synchronous processing does not affect the ability of \code{Observable}s to handle asynchronous data.

However, this synchronous behavior might not always be the best solution, especially in real world applications, where we might want to have a thread dedicated to listening to incoming events and one which processes them. Enter the \code{Scheduler} interface, an orthogonal\cite{wiki:orthogonality} structure w.r.t. \code{Observable} which allows us to introduce concurrency into our reactive equation. 

\code{Scheduler}s allow us to to alter the control flow of the data processing within an observable expression, introducing a way to dispatch the work of any number of operators to be executed within the specified context, e.g. a new thread.

The \code{Scheduler} interface looks like the following \footnote{The interface presented in this section is the result of a simplification of the actual one, which involves \code{Subscription}s. We will discuss the impact of \code{Subscription}s on \code{Schedulers} in the next section; suffices to know that the version presented here has no negative effects w.r.t the generality of our discussion.}.\\

\haskellcode[firstline=31,lastline=34]{src/scheduler.hs}\\

\code{Scheduler}s expose two functions which are essentially equal, modulo arbitrary delays in time. Both of these functions take an \code{IO} action as input and dispatch it to the appropriate execution context, producing a side effect. 

To better understand \code{Scheduler}s, let us present the implementation of one of them, the newThread scheduler, which allows us to dispatch action to a new, dedicated thread.\\

\haskellcode[firstline=36,lastline=47]{src/scheduler.hs}\\

The \code{newThread} function gives us a side effectful way of creating a \code{Scheduler} by generating a new execution context - i.e. a new thread - and setting up the necessary tools for safe communication with it. The \code{Scheduler} functions we are provided, on the other hand, simply write the input \code{IO} action to the channel and return, effectively dispatching the execution of those actions to the new thread. 

Up to this point we haven't mentioned \code{Observable}s at all. This is the reason why we previously claimed that \code{Scheduler} and \code{Observable} are connected by an orthogonal relationship: the two interfaces are independent from one another, yet, when used together within an observable expression, they provide the user with greater expressive power w.r.t. concurrency. 

The only thing missing now is a way for us to combine the functionality of these two interfaces: \code{observeOn} and \code{subscribeOn} are the operators that will aid us on this task. The former will allow us to dispatch any call to an observer continuation on to the specified execution context, whereas the latter will allow us to control the concurrency of the \code{Observable} subscribe function.

For the sake of completeness and understandability, the following snippet contains a simple implementation of the \code{observeOn} operator together with a sample usage.\\

\haskellcode[firstline=49,lastline=58]{src/scheduler.hs}\\

\haskellcode[firstline=60]{src/scheduler.hs}\\


\subsection{A note on the concept of time}

Our discussion on push-based collections so far has not once mentioned the concept of time. This might appear strange, especially to the reader familiar with Functional Reactive Programming, where functions over continuous time are at the foundations of the theory. As we mentioned in Section \ref{frp}, this dependency on continuous time comes at a great cost: commercial FRP libraries fail to successfully implement the concepts found in the theory as they cannot avoid simulating continuous time and approximating functions operating over it, being this concept inherently discrete in the context of computers.

Rx, on the other hand, completely sheds the notion of time from the notion of reactivity\cite{meijer2010observable}, shifting its focus, with the help of \code{Scheduler}s, to concurrency instead. Time still plays a role, although indirect, within the library: events are processed in the order they happen, and operators make such order is maintained, ultimately handing over to the user a stream of time-ordered events. See Section \ref{sec:contract} for a broader discussion on this matter.

\subsection{Impact on Operators}

Previously we discussed how introducing concurrency is an orthogonal concept w.r.t. our reactive library. This statement is only partly true and falls short of its promises when we are dealing with combiner operators (see Section \ref{operators}) such as \code{(>>=)} or \code{combineLatest}. These operators will not work at their full potential in a synchronous setting, due to the fact that subscribing to a stream will consume it entirely - or forever process, in the case of an infinite stream - before allowing the operator to subscribe to a different one, effectively making interleaving of events impossible.

The problem is gracefully solved with the introduction of \code{Scheduler}s, which, by allowing for \code{Observable}s to be executed on different contexts, indirectly make it possible for interleaving to happen and for combiner operators to work at their full potential. This comes at a - even though small - cost, which motivates our claim of partial orthogonality: the internal state of a combiner operator needs to be synchronized and carefully handled as, with the introduction of concurrency, it can now be modified from different execution contexts.


\section{Subscriptions}
\label{sec:subscriptions}

-----------------------------------------------------------------------

- now purely practical concern: stop stream while processing from anywhere, tell observable I dont want to observe anymore, i.e. the observer is done.
- what is it: IO action/s | in theory can be seen as readerT, the subscription is always the same one, but you can add stuff to it. 
- who does it belong to: the observer, you get one for each subscribe.
- how does it work: call unsubscribe, best effort stop work
- impact on operators: a need for children -> now you can free resources 
- impact on schedulers: kill the thread
- write that it only works now that we have schedulers
- edge enforcement
- subject + takeuntil
- why cannot be monoid, we need remove

-----------------------------------------------------------------------

With schedulers, we are now able to handle observable streams from different execution contexts. The next step is to add a mechanism that will allow us to stop a stream from anywhere in our program, whenever we don't require it's data - i.e. a mechanism to tell the \code{Observable} that one of it's \code{Observer}s is not interested in receiving events anymore. We are going to do so by augmenting our informal definition of \code{Observable} from section \ref{obscont} with a new function \code{(\%)}, which incorporates the notion of a cancellation mechanism through the \code{Subscription} datatype:\\

\hminted
%a  :: a -> IO Subscription
%?a :: (Either SomeException (Maybe a) -> IO ()) -> IO Subscription
\end{minted}
\\

With this change, each execution of the \code{Observable} function now returns a \code{Subscription}, a means for the user to prematurely terminate the processing of the stream. 

We discussed in the previous section how schedulers effectively boost the expressive power of our reactive expressions by introducing concurrency and interleaving among events originating from different streams. Introducing a cancellation mechanism, on the other hand, is a purely practical concern: although very useful from a practical perspective, especially in the context of resource management, it doesn't impact expressive power from a reactive point of view.

The first step in designing this new feature is to understand how the already existing interfaces will be affected by the newly introduced one; we just saw how the \code{\_subscribe} function should now return an action resulting in an instance of type \code{Subscription}. The next question is the following: to whom does a \code{Subscription} belongs to? The key observation in addressing this question is that an \code{Observable} can be subscribed to by multiple \code{Observer}s; our goal is to provide a mechanism that will allow for a fine-grained control over which \code{Observer} is supposed to stop receiving events. The answer is then straightforward: the notion of subscription is tight to that of observer. The following snippet incorporates this notion:\\

\hminted
$a  :: (Subscription, Either SomeException (Maybe a) -> IO ())
%$a :: (Subscription, Either SomeException (Maybe a) -> IO ()) 
	-> IO Subscription
\end{minted}
\\

Let's quickly summarize what we have discussed so far: a subscription is some object which will allow us to prematurely stop observing a specific stream; since any stream can be subscribed to by multiple observers, we need to associate subscriptions to observers as opposed to observables. Lastly, a subscription is returned every time an observer is subscribed to a stream through the \code{\_subscribe} function. The following modifications to our reactive interfaces reflect these ideas:\\

\haskellcode[firstline=12,lastline=21]{src/subsciption.hs}\\

\todo[inline]{do not subscribe an observer to 2 different streams}
So far we have talked a lot about \code{Subscription}s, yet we haven't clarified what the type really looks like. The general idea is to have \code{Subscription} record the state of the \code{Observer} w.r.t. the \code{Observable} it is subscribed to - be that subscribed or unsubscribed. This can be easily achieved with a variable \code{\_isUnsubscribed :: IORef Bool} initialized to \code{False}, indicating that the associated \code{Observer} is initially not unsubscribed.

From a practical point of view, it is useful to augment \code{Subscription} with some additional functionality. The following code shows a definition of \code{Subscription} which incorporates an \code{IO ()} action to be executed at unsubscription time. This is particularly useful when we want to associate resource cleanup actions to the termination - be that forced or natural - of a stream observation. \\

\hminted
data Subscription = Subscription
	{ _isUnsubscribed :: IORef Bool
	, onUnsubscribe   :: IO ()
	}
\end{minted}
\\

We will see, later on, how we can further augment this interface in order to incorporate additional functionality useful for internal operator coordination as well as management of schedulers. 

It's now time to introduce the two functions at the hearth of the whole cancellation mechanism: \code{unsubscribe} will take care of modifying the state carried by the \code{Subscription} - i.e. setting \code{\_isUnsubscribed} to \code{False} - whereas \code{subscribe} will act as a proxy for the \code{\_subscribe} function from \code{Observable}, calling it with a special \code{Observer} which will prevent events from propagating to the downstream once the \code{Subscription} has been unsubscribed. Note how, for this mechanism to work, it is necessary the two \code{Observer}s to share the same \code{Subscription}.

\haskellcode[firstline=71,lastline=84]{src/subsciption.hs}\\
 

So, what is a \code{Subscription} then? Conceptually, it could be a simple boolean recording whether an \code{Observer} is unsubscribed from the stream. In practice it is useful to augment it with some additional information. First of all, \code{Subscription}s can be used for resource cleanup at the termination - either forced or natural - of a stream. It is therefore useful to associate an \code{IO ()} action to the datatype, which will represent the computation to be executed once the stream is unsubscribed from. Another improvement is making the type recursive, i.e. allowing \code{Subscription}s to contain, add and remove children subscriptions. This will be extremely useful for internal coordination of operators such as \code{(>>=)} and for resource management in the context of schedulers - more on this in the next sub-subsections.

\todo[inline]{We could just chain IO actions, but then we cant remove, which can lead to stack overflow with huge thunks in flatmap.}

\todo[inline]{Talk about the best effort in canceling work and eventual consistency with the contract.}

\haskellcode[firstline=34,lastline=38]{src/subsciption.hs}\\


As a design decision, when unsubscribe is called on an observable subscription, the observable sequence will make a best effort attempt to stop all outstanding work. This means that any queued work that has not been started will not start. Any work that is already in progress might still complete as it is not always safe to abort work that is in progress. Results from this work will not be signaled to any previously subscribed observer instances.

\todo[inline]{Motivation for children subscriptions: some operators will create inner observables and therefore will need to unsubscribe from them when the outer observable is unsubscribed from.}

--------------------------------------------------\\
On why using Cont () (StateT Subscription IO) (Event a) wouldn't work: it would be perfect in order to thread Subscriptions throughout execution making it usable inside operators, since the call to the continuation would return a state which would then be sequenced by >>=. This method fails with schedulers, in particular newThread since the state of the action executed on the new thread would be disconnected from the threading mentioned above. The other thread would get a state but it would not know what to do with it and would not have any ways to connect it to the original one passed by the subscribe. Another way is to use mapStateT to map the IO action that will result from the state to an action on the other thread. Again, this method won't work, 

--------------------------------------------------\\
On the motivation for a Subscription: it is needed so the user can cancel work at any time. This implies that a scheduler is used. If this is not the case the subscription will be returned synchronously after the execution of the whole stream. It will therefore be already unsubscribed and calling unsubscribe will be a NoOp. In the case that we actually use schedulers then we can unsubscribe from anywhere in our program. 

Now the question is the following: can we reproduce the behaviour of unsubscribe with operators so that we can eliminate subscriptions altogether? That is, we can hide them to the outside and use them only inside the stream, we still need them but we don't necessarily need to return them when we subscribe. The behavious can be easily replaced by the use of takeUntil(Observable a) where we pass in a subject that will be signaled when we want to stop the stream. The takeUntil operator fires events from the upstream up until the point in which we signal the subject, then stops the stream and unsubscribes. 

With this approach we seemingly lose one thing, i.e. the ability to specify what happens at unsubscription time; this functionality can simply be regained by a subscribe function that takes the unsubscribe action as a parameter and runs it when the stream is unsubscribed.
--------------------------------------------------

\section{Operators}
\label{operators}

--------------------------------------------------------------------------------

The first thing we want to re-introduce is handling exceptions and termination of a stream. Where an Iterable can return a value, terminate or throw an exception when we ask for a value, and Observable, being it's dual, can produce one or more values, terminate or throw an exception when it is subscribed to. 

A more appropriate type for our interface is then the following.\\

\haskellcode[firstline=4,lastline=5]{src/obs_contT.hs}\\

\todo[inline]{Remove this Event shit and move to the custom type directly? Not sure, I like the discussion on bind.}

Now, this code is not exactly the definition of readable; let's apply some good design skills to make it more pleasant to the eye without changing it's meaning.\\

\haskellcode[firstline=4,lastline=11]{src/obs_events.hs}\\

Although this might not look like a big change, it greatly influences the design of our API. We are, in fact, changing our instantiation of the continuation monad to an input type that is not \code{a} anymore, but \code{Event a}. On the other hand, out type variable for Observable is still \code{a}. This is not an issue per se, but it has one big consequence: the flatmap function that we inherit from the continuation monad is not the one that we want to expose from out API anymore. The types differ like so.\\

\haskellcode[firstline=13,lastline=17]{src/obs_events.hs}\\

This has many implications, first of all, we are gonna need to implement flatmap by ourselves.. see todo below...

It has now come the time to move away from an implementation of Observable as a type synonym. We have already seen how the current implementation using \code{Event a} does not allow for a correspondence between \code{>>=} operations; this will only create confusion in the future. The next step is then to define our own observable tybe, which will clearly be really similar to the Continuation monad and subsequently prove that it is itself a monad. 

----------------------------------------------------
\begin{minted}{haskell}
newtype Observable a = Observable { subscribe :: Observer a -> IO () } 
data Observer a = Observer 
    { onNext       :: a -> IO ()
    , onError      :: SomeException -> IO ()
    , onCompleted  :: IO ()
    }
\end{minted}
----------------------------------------------------    

With this implementation we have eliminated the materialisation of the event types. The Observer is now not a single function from \code{Event a -> IO ()} but a collection of 3 continuations that will be used inside the observable depending on the type of the event. It is clear that this implementation of Observable has not changed in functionality from the previous one using the Continuation Monad, it has just dematerialized the 3 types of events in 3 functions which handle them.

The next step is to make Observable a monad

----------------------------------------------------
\begin{minted}{haskell}
instance Monad Observable where
	return a = observable (\obr -> onNext obr a)
	o >>= f = ...
\end{minted}
----------------------------------------------------  

The return function is the exact same as in the continuation monad, with the only difference that we have now 3 continuations to chose from instead of a single one. 

Bind, on the other hand, is completely different from the Cont monad implementation; in this case ... \todo[inline]{finish the discussion}

The only thing left to do now is to prove the monad laws to show that Observable really is a monad.

\haskellcode[firstline=19,lastline=22]{src/obs_events.hs}\\

We mentioned before how the bind from Cont differs from our in the Observable. Below I will show that in this implementation it corresponds to a function lift that ... \todo[inline]{Talk about lift = >>= in Cont.}

By using lift we can transform streams and implement operators...

\todo[inline]{Modify keyboard press example from before to handle errors and termination. Point to later discussion regarding the rx contract, since now we can detect termination and errors but there is no guarantee that nothing will come after we receive them, i.e. that we abide the contract.}


